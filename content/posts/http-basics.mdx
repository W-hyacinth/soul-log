---
title: "HTTP 기본"
description: "HTTP의 역사와 특징, 클라이언트-서버 구조, Stateless와 비연결성, 그리고 HTTP 메시지 구조를 정리합니다."
date: 2022-06-19
tags: ["Network", "HTTP", "HTTP 웹 기본"]
cover: null
---

## 모든 것이 HTTP

**H**yper **T**ext **T**ransfer **P**rotocol

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송이 가능합니다.
- 서버 간에 데이터를 주고받을 때도 대부분 HTTP를 사용합니다.

### HTTP 역사

| 버전 | 연도 | 비고 |
|---|---|---|
| HTTP/1.1 | 1997년 | 현재 가장 많이 사용 중 |
| HTTP/2 | 2015년 | 성능 개선 |
| HTTP/3 | 진행 중 | TCP 대신 UDP 사용, 성능 개선 |

### 기반 프로토콜

| 프로토콜 | HTTP 버전 |
|---|---|
| TCP | HTTP/1.1, HTTP/2 |
| UDP | HTTP/3 |

### HTTP 특징

- 클라이언트 서버 구조
- 무상태 프로토콜(Stateless), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

---

## 클라이언트 서버 구조

- 클라이언트와 서버가 서로 분리되어 있습니다.
  - 과거에는 클라이언트와 서버가 합쳐져 있는 경우도 많았습니다.
  - 비즈니스 로직과 데이터는 서버에서 관리합니다.
  - UI나 사용성 부분은 클라이언트에서 관리합니다.
  - 서로 분리되어 있으면 각각 독립적으로 진화할 수 있습니다.
    - 예를 들어 서비스가 폭발적으로 성장할 경우 트래픽과 같은 부분을 고민해야 하는데, 이 경우 백엔드에서는 서버의 아키텍처만 고민하고 클라이언트에서는 고민하지 않아도 됩니다.
- Request Response 구조입니다.
- 클라이언트는 서버에 요청을 보내고 응답을 대기합니다.
- 서버가 요청에 대한 결과를 만들어서 응답합니다.

---

## 무상태 프로토콜 (Stateless)

- 서버가 클라이언트의 상태를 보존하지 않습니다.

### Stateful, Stateless의 차이

- **Stateful** (상태유지)
  - 중간에 다른 서버로 바뀌면 안 됩니다.
  - 중간에 다른 서버로 바뀔 경우, 상태 정보를 다른 서버에 알려줘야 합니다.
- **Stateless** (무상태)
  - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있습니다.
  - 응답 서버가 바뀌더라도 응답이 가능합니다. (무한한 서버 증설 가능)

### Stateless의 실무 한계

- 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있습니다.
- **무상태**: 로그인이 필요 없는 페이지
- **상태유지**: 로그인
- 로그인한 사용자의 경우, 로그인했다는 상태를 서버에 유지해야 합니다.
- 일반적으로 브라우저 쿠키나 서버 세션 등을 사용해서 상태를 유지합니다.
- 상태 유지는 최소한으로 사용하는 것이 좋습니다.

---

## 비연결성

- HTTP는 기본이 연결을 유지하지 않는 모델입니다.
- 일반적으로 초 단위 이하의 빠른 속도로 응답합니다.
- 1시간 동안 수천 명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십 개 이하로 매우 작습니다.
- 서버 자원을 매우 효율적으로 사용할 수 있습니다.

### 연결을 유지하는 모델

- 서버가 각각 `클라이언트 1`, `클라이언트 2`, `클라이언트 3`과 통신하는 동안 연결 상태를 유지합니다.
- 이 경우 굳이 통신하지 않고 있더라도 서버의 자원을 불필요하게 계속 소모하게 됩니다.

### 연결을 유지하지 않는 모델

- 서버가 각각 `클라이언트 1`, `클라이언트 2`, `클라이언트 3`과 통신할 경우, 통신하지 않는 클라이언트와의 연결을 끊습니다.
- 이 경우 서버의 자원을 최소한으로 소모하게 됩니다.

### 비연결성의 한계와 극복

- 매번 `TCP/IP` 연결을 새로 맺어야 합니다.
- 웹 브라우저로 사이트를 요청하면 HTML, Javascript, CSS, 이미지 등 수많은 자원이 함께 다운로드됩니다.
- 현재는 HTTP 지속 연결(Persistent Connections)로 문제를 해결하고 있습니다.

![HTTP 연결 종료 모델](/images/http-basics/http-connection-close.png)

![HTTP 지속 연결 모델](/images/http-basics/http-persistent-connection.png)

- HTTP/2, HTTP/3에서 더 많은 최적화가 이루어졌습니다.

---

## HTTP 메시지

- HTTP 메시지는 매우 단순합니다.
- 단순하면서도 확장 가능한 기술들은 대체로 크게 성공합니다.

![HTTP 메시지 구조](/images/http-basics/http-message-structure.png)

- Start-line
- Header
- Empty-line
- Message body

### 시작 라인 - 요청

```
GET /search?q=hello&hl=ko HTTP/1.1
Host: www.google.com
```

- **request-line** / status-line
- HTTP 메서드
  - 종류: GET, POST, PUT, DELETE, PATCH 등
  - 서버가 수행해야 할 동작을 지정합니다.
- 요청 대상
  - 절대경로[?쿼리]
- HTTP Version
  - `HTTP/1.1`

### 시작 라인 - 응답

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
  <body>...</body>
</html>
```

- request-line / **status-line**
- HTTP 버전
- HTTP 상태 코드: 요청 성공, 실패를 나타냅니다.
  - 200: 성공
  - 400: 클라이언트 요청 오류
  - 500: 서버 내부 오류
- 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

---

## HTTP 헤더

- `header-field = field-name: OWS field-value OWS`
- HTTP 전송에 필요한 모든 부가정보를 포함합니다.
  - 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등
- 표준 헤더가 많습니다.
  - [List of HTTP header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields)
- 필요에 따라서는 임의의 헤더를 추가할 수도 있습니다.

---

## HTTP 메시지 바디

- 실제 전송할 데이터입니다.
- HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터를 전송할 수 있습니다.
